<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><link rel=icon type=image/ico href=https://blog.yzyy.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.yzyy.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.yzyy.de/favicon-32x32.png><link rel=icon type=image/png sizes=192x192 href=https://blog.yzyy.de/android-chrome-192x192.png><link rel=apple-touch-icon sizes=180x180 href=https://blog.yzyy.de/apple-touch-icon.png><link rel=alternate type=application/rss+xml href=https://blog.yzyy.de/explore/index.xml title=G-Hung的博客><meta name=description content><title>Explores | G-Hung的博客</title><link rel=canonical href=https://blog.yzyy.de/explore/><meta property="og:url" content="https://blog.yzyy.de/explore/"><meta property="og:site_name" content="G-Hung的博客"><meta property="og:title" content="Explores"><meta property="og:description" content="一个关于Java后端开发和技术学习的个人博客"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="website"><link rel=stylesheet href=/assets/combined.min.737dab787e0dfa3088180adf040304574c336cd3805516c938598d23fd96b675.css media=all><script async src="https://www.googletagmanager.com/gtag/js?id=G-88BLW4V0HZ"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-88BLW4V0HZ")}</script></head><body class=auto><div class=content><header><div class=header><h1 class=header-title><a href=https://blog.yzyy.de/>G-Hung的博客</a></h1><div class=header-menu><p class=small><a href=/>/home</a></p><p class=small><a href=/post>/日常</a></p><p class=small><a href=/explore>/探索记录</a></p><p class=small><a href=/tags>/tags</a></p><a href=/index.xml target=_blank title=RSS class=rss-icon><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></div></div></header><main class=main><div class=list-container><div class=breadcrumbs><a href=/>Home</a><span class=breadcrumbs-separator>/</span>
<a href=/explore/>Explores</a></div><h1>Explores</h1><div class=post-line><p class=line-date>2025 Jul 30</p><div><p class=line-title><a href=/explore/self-host/syncclipboard%E6%9B%BF%E4%BB%A3%E5%BE%AE%E4%BF%A1%E8%BE%93%E5%85%A5%E6%B3%95%E5%90%8C%E6%AD%A5%E5%8A%9F%E8%83%BD%E7%9A%84%E6%9C%80%E4%BD%B3%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/>SyncClipboard：替代微信输入法同步功能的最佳解决方案</a></p><p class=line-summary>介绍 SyncClipboard 这款跨平台剪贴板同步工具以及部署流程，作为微信输入法同步功能的最佳替代方案，实现多设备间内容无缝传输。</p></div></div><div class=post-line><p class=line-date>2024 Jun 12</p><div><p class=line-title><a href=/explore/self-host/vaultwarden%E8%87%AA%E5%BB%BA%E5%AF%86%E7%A0%81%E5%BA%93/>自建Vaultwarden密码库：从部署到安全备份</a></p><p class=line-summary>记录了如何使用Docker和Nginx自建Vaultwarden密码库，并涵盖了安全加固与多云端自动备份的完整流程。</p></div></div><div class=post-line><p class=line-date>2024 May 8</p><div><p class=line-title><a href=/explore/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E5%9F%9F%E5%90%8D%E7%9B%B8%E5%85%B3/>域名管理：Cloudflare DNS托管与SSL证书配置</a></p><p class=line-summary>记录域名管理一些操作，涵盖了使用Cloudflare进行DNS解析与托管，对比并介绍了通过Cloudflare服务与acme.sh脚本两种方式申请和自动化管理SSL/TLS证书的完整步骤。</p></div></div><div class=post-line><p class=line-date>2024 Apr 12</p><div><p class=line-title><a href=/explore/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95/>新到手的Linux VPS, 我这样设置：从安全加固到Nginx反代部署</a></p><p class=line-summary>涵盖了从安全设置、Docker安装、Nginx反向代理及SSL证书配置，到Swap空间管理的完整步骤。</p></div></div><div class=post-line><p class=line-date>2024 Apr 10</p><div><p class=line-title><a href=/explore/%E6%9C%8D%E5%8A%A1%E5%99%A8/vps%E5%9F%BA%E6%9C%AC%E5%AE%89%E5%85%A8%E6%8E%AA%E6%96%BD/>VPS基础安全配置实践指南</a></p><p class=line-summary>记录了新购VPS后必须进行的一系列基础安全设置，旨在提升服务器的防御能力，防止常见攻击。</p></div></div><div class=post-line><p class=line-date>2024 Feb 29</p><div><p class=line-title><a href=/explore/%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/>图床搭建(Cloudflare R2 + WebP Cloud + PicList)</a></p><p class=line-summary>Cloudflare R2 + WebP Cloud + PicList 免费图床搭建全流程</p></div></div><div class=post-line><p class=line-date>2023 Oct 8</p><div><p class=line-title><a href=/explore/obsidian%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/>Obsdian的一些使用技巧</a></p><p class=line-summary>个人的Obsidian高效使用技巧的记录，助力提升笔记管理与工作流效率。</p></div></div><div class=post-line><p class=line-date>2023 Oct 6</p><div><p class=line-title><a href=/explore/obsidian%E4%B8%AA%E4%BA%BA%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/>Obsdian个人配置记录</a></p><p class=line-summary>Obsidian配置与同步备份全流程实录，涵盖iCloud与Git自动化方案及多种同步备选。</p></div></div><div class=post-line><p class=line-date>0001 Jan 1</p><div><p class=line-title><a href=/explore/springai/springai-memory-flow/></a></p><p class=line-summary><h1 class=heading id=spring-ai-对话记忆管理流程图>Spring AI 对话记忆管理流程图
<a class=anchor href=#spring-ai-%e5%af%b9%e8%af%9d%e8%ae%b0%e5%bf%86%e7%ae%a1%e7%90%86%e6%b5%81%e7%a8%8b%e5%9b%be>#</a></h1><p>本文档展示了 Spring AI 对话记忆管理的完整流程，以用户发送消息 <code>"帮我总结一下刚才的内容"</code> (conversationId: <code>"user-9527"</code>) 为例。</p><h2 class=heading id=完整时序图>完整时序图
<a class=anchor href=#%e5%ae%8c%e6%95%b4%e6%97%b6%e5%ba%8f%e5%9b%be>#</a></h2><p><figure><div class=img-container><img loading=lazy alt=Image_2025-11-25_16-17-39_vavz5awg.vhe.png src=https://webp.050612.xyz/2025/11/20251125161755002.png></div></figure></p><pre class=mermaid>sequenceDiagram
    autonumber
    participant User as 用户/前端
    participant Controller as Controller
    participant ChatClient as ChatClient
    participant Advisor as MessageChatMemoryAdvisor
    participant Memory as TokenWindowChatMemory
    participant Repo as RedisChatMemoryRepository
    participant Redis as Redis
    participant AI as AI模型

    rect rgb(240, 248, 255)
        Note over User,Redis: 第一阶段:读取与筛选 (Before Request)
        User-&gt;&gt;Controller: 发送消息 (conversationId: user-9527)
        Controller-&gt;&gt;ChatClient: chatClient.prompt().user(...).call()
        ChatClient-&gt;&gt;Advisor: 拦截请求 (Before Request)
        Note over Advisor: 发现 conversationId=user-9527
        
        Advisor-&gt;&gt;Memory: get(user-9527, ...)
        Note over Advisor,Memory: 请求历史记忆
        
        Memory-&gt;&gt;Repo: 查询存储的消息
        Repo-&gt;&gt;Redis: redisTemplate.opsForValue().get(chat:memory:user-9527)
        Note over Redis: 返回 JSON 字符串 (50条历史对话)
        Redis--&gt;&gt;Repo: String (JSON)
        Repo--&gt;&gt;Memory: 反序列化为 List Message (全量50条)
        
        Note over Memory: Token策略计算: 1.引入Tokenizer 2.从最后一条往前倒推 3.累加至2000Token限制 4.倒数第8条时满了
        Memory--&gt;&gt;Advisor: 返回精简切片 (8条历史+SystemMessage)
    end

    rect rgb(255, 250, 240)
        Note over Advisor,AI: 第二阶段:组装与发送 (Requesting)
        Note over Advisor: 组装最终Prompt: SystemPrompt + 8条历史 + 当前新问题
        Advisor-&gt;&gt;AI: 发送完整请求包
    end

    rect rgb(240, 255, 240)
        Note over AI: 第三阶段:AI响应 (Response)
        Note over AI: AI理解上下文并思考
        AI--&gt;&gt;Advisor: 返回回复内容
    end

    rect rgb(255, 240, 245)
        Note over Advisor,Redis: 第四阶段:写入与更新 (After Request)
        Note over Advisor: 捕获本轮对话: 用户提问 + AI回复
        
        Advisor-&gt;&gt;Memory: add(user-9527, [UserMsg, AssistantMsg])
        Note over Memory: 追加新消息到列表 (50条→52条)
        
        Memory-&gt;&gt;Repo: update(...)
        Repo-&gt;&gt;Redis: 序列化为JSON并覆盖写入, 刷新TTL
        Redis--&gt;&gt;Repo: 确认写入
        Repo--&gt;&gt;Memory: 更新成功
        Memory--&gt;&gt;Advisor: 存储完成
    end
    
    Advisor--&gt;&gt;ChatClient: 返回AI响应
    ChatClient--&gt;&gt;Controller: 返回结果
    Controller--&gt;&gt;User: 返回回复内容
</pre><h2 class=heading id=数据形态变化表>数据形态变化表
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e5%bd%a2%e6%80%81%e5%8f%98%e5%8c%96%e8%a1%a8>#</a></h2><div class=table-outer><table><thead><tr><th style=text-align:left>环节</th><th style=text-align:left>数据形态</th><th style=text-align:center>数量示例</th><th style=text-align:left>备注</th></tr></thead><tbody><tr><td style=text-align:left><strong>Redis 中</strong></td><td style=text-align:left><code>String</code> (JSON)</td><td style=text-align:center>50条</td><td style=text-align:left><strong>全量存档</strong>。例如：<code>[{"role":"user","content":"..."}, ...]</code></td></tr><tr><td style=text-align:left><strong>Repo → Memory</strong></td><td style=text-align:left><code>List&lt;Message></code></td><td style=text-align:center>50条</td><td style=text-align:left><strong>全量对象</strong>。内存里有 50 个 Message 对象</td></tr><tr><td style=text-align:left><strong>Memory → Advisor</strong></td><td style=text-align:left><code>List&lt;Message></code></td><td style=text-align:center>8条</td><td style=text-align:left><strong>精简切片</strong>。经过 Token 算法裁剪，只剩 8 个 Message 对象</td></tr><tr><td style=text-align:left><strong>发给 AI 的包</strong></td><td style=text-align:left><code>Prompt</code></td><td style=text-align:center>1+8+1</td><td style=text-align:left><strong>最终请求</strong>。包含 System + 8条历史 + 1条新消息</td></tr><tr><td style=text-align:left><strong>Redis (更新后)</strong></td><td style=text-align:left><code>String</code> (JSON)</td><td style=text-align:center>52条</td><td style=text-align:left><strong>全量存档+2</strong>。变成了 52 条，等待下一次调用</td></tr></tbody></table></div><h2 class=heading id=核心组件职责>核心组件职责
<a class=anchor href=#%e6%a0%b8%e5%bf%83%e7%bb%84%e4%bb%b6%e8%81%8c%e8%b4%a3>#</a></h2><pre class=mermaid>graph TB
    subgraph &#34;存储层&#34;
        Redis[(Redis 数据库)]
        Repo[RedisChatMemoryRepository]
    end
    
    subgraph &#34;策略层&#34;
        Memory[TokenWindowChatMemory]
        Tokenizer[Token 计算器]
    end
    
    subgraph &#34;增强层&#34;
        Advisor[MessageChatMemoryAdvisor]
    end
    
    subgraph &#34;应用层&#34;
        ChatClient[ChatClient]
        Controller[Controller]
    end
    
    Controller --&gt; ChatClient
    ChatClient --&gt; Advisor
    Advisor --&gt; Memory
    Memory --&gt; Tokenizer
    Memory --&gt; Repo
    Repo --&gt; Redis
    
    style Redis fill:#ffcccc
    style Repo fill:#ffe6cc
    style Memory fill:#fff4cc
    style Tokenizer fill:#fff4cc
    style Advisor fill:#e6f3ff
    style ChatClient fill:#f0f0f0
    style Controller fill:#f0f0f0
</pre><h2 class=heading id=token-窗口计算流程>Token 窗口计算流程
<a class=anchor href=#token-%e7%aa%97%e5%8f%a3%e8%ae%a1%e7%ae%97%e6%b5%81%e7%a8%8b>#</a></h2><pre class=mermaid>flowchart TD
    Start([收到50条历史消息]) --&gt; Init[初始化 Token 计数器 = 0]
    Init --&gt; Loop{从最后一条往前遍历}
    Loop --&gt;|取一条消息| Calc[计算该消息的 Token 数]
    Calc --&gt; Add[累加到计数器]
    Add --&gt; Check{累加后是否超过2000 Token?}
    Check --&gt;|否| Loop
    Check --&gt;|是| Stop[停止遍历]
    Stop --&gt; Result[返回最近的 8 条消息]
    Loop --&gt;|遍历完所有消息| Result
    Result --&gt; End([发送给 Advisor])
    
    style Start fill:#e1f5e1
    style End fill:#e1f5e1
    style Check fill:#ffe6e6
    style Result fill:#e6f3ff
</pre><h2 class=heading id=设计优势>设计优势
<a class=anchor href=#%e8%ae%be%e8%ae%a1%e4%bc%98%e5%8a%bf>#</a></h2><h3 class=heading id=1-职责分离>1. <strong>职责分离</strong>
<a class=anchor href=#1-%e8%81%8c%e8%b4%a3%e5%88%86%e7%a6%bb>#</a></h3><ul><li><strong>Redis</strong>：只管存 JSON，不懂业务逻辑</li><li><strong>Repository</strong>：只管序列化/反序列化，不懂 Token</li><li><strong>Memory</strong>：只管 Token 计算，不管 IO</li><li><strong>Advisor</strong>：只管请求增强，不管存储细节</li></ul><h3 class=heading id=2-性能优化>2. <strong>性能优化</strong>
<a class=anchor href=#2-%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96>#</a></h3><ul><li>Token 计算在内存中完成，速度极快</li><li>Redis 存储全量数据，但只传输必要的切片给 AI</li><li>避免每次都重新计算整个对话历史</li></ul><h3 class=heading id=3-可扩展性>3. <strong>可扩展性</strong>
<a class=anchor href=#3-%e5%8f%af%e6%89%a9%e5%b1%95%e6%80%a7>#</a></h3><ul><li>可以轻松替换存储层（Redis → MySQL → MongoDB）</li><li>可以调整 Token 窗口大小</li><li>可以实现不同的记忆策略（滑动窗口、摘要压缩等）</li></ul><h3 class=heading id=4-ai-友好>4. <strong>AI 友好</strong>
<a class=anchor href=#4-ai-%e5%8f%8b%e5%a5%bd>#</a></h3><ul><li>无论 Redis 存了多少条消息，发给 AI 的永远不会超过 Token 限制</li><li>保证 AI 始终能获得最相关的上下文</li><li>避免超长请求导致的错误或额外费用</li></ul></p></div></div></div></main></div><footer><p>All content licensed under <a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a> unless otherwise stated. Copyright © 2025 ghung<br>Powered by <a href=https://gohugo.io/>Hugo</a> and <a href=https://github.com/tomfran/typo>tomfran/typo</a></p></footer></body><script src=/js/theme-switch.js></script><script defer src=/js/copy-code.js></script></html>