<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><link rel=icon type=image/ico href=https://blog.yzyy.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.yzyy.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.yzyy.de/favicon-32x32.png><link rel=icon type=image/png sizes=192x192 href=https://blog.yzyy.de/android-chrome-192x192.png><link rel=apple-touch-icon sizes=180x180 href=https://blog.yzyy.de/apple-touch-icon.png><meta name=description content="一篇为运维工程师准备的Docker实战教程。本文详细讲解了如何通过创建和使用共享的外部Docker网络（external network），优雅地解决多个 docker-compose 项目之间容器无法通信的难题，这是构建分布式和微服务应用的行业标准与最佳实践。"><title>如何让两个 docker-compose 项目中的容器互相通信 | G-Hung的博客</title><link rel=canonical href=https://blog.yzyy.de/post/%E5%A6%82%E4%BD%95%E8%AE%A9%E4%B8%A4%E4%B8%AA-docker-compose-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8%E4%BA%92%E7%9B%B8%E9%80%9A%E4%BF%A1/><meta property="og:url" content="https://blog.yzyy.de/post/%E5%A6%82%E4%BD%95%E8%AE%A9%E4%B8%A4%E4%B8%AA-docker-compose-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8%E4%BA%92%E7%9B%B8%E9%80%9A%E4%BF%A1/"><meta property="og:site_name" content="G-Hung的博客"><meta property="og:title" content="如何让两个 docker-compose 项目中的容器互相通信"><meta property="og:description" content="一篇为运维工程师准备的Docker实战教程。本文详细讲解了如何通过创建和使用共享的外部Docker网络（external network），优雅地解决多个 docker-compose 项目之间容器无法通信的难题，这是构建分布式和微服务应用的行业标准与最佳实践。"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-07-28T00:00:00+00:00"><meta property="article:modified_time" content="2025-07-28T00:00:00+00:00"><meta property="article:tag" content="服务器"><meta property="article:tag" content="探索"><link rel=stylesheet href=/assets/combined.min.b72766531fc58b8c9eb741223d816b1c10ab962791e1d50d5f6fcb81345cde80.css media=all><script async src="https://www.googletagmanager.com/gtag/js?id=G-88BLW4V0HZ"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-88BLW4V0HZ")}</script></head><body class=auto><div class=content><header><div class=header><h1 class=header-title><a href=https://blog.yzyy.de/>G-Hung的博客</a></h1><div class=header-menu><p class=small><a href=/>/home</a></p><p class=small><a href=/post>/日常</a></p><p class=small><a href=/explore>/探索记录</a></p><p class=small><a href=/tags>/tags</a></p><a href=/index.xml target=_blank title=RSS class=rss-icon><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></div></div></header><main class=main><div class=breadcrumbs><a href=/>Home</a><span class=breadcrumbs-separator>/</span><a href=/post/>Posts</a><span class=breadcrumbs-separator>/</span>
<a href=/post/%E5%A6%82%E4%BD%95%E8%AE%A9%E4%B8%A4%E4%B8%AA-docker-compose-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8%E4%BA%92%E7%9B%B8%E9%80%9A%E4%BF%A1/>如何让两个 docker-compose 项目中的容器互相通信</a></div><div class=autonumber><article><header class=single-intro-container><h1 class=single-title>如何让两个 docker-compose 项目中的容器互相通信</h1><p class=single-summary>在使用 Docker 时，创建一个共享的外部网络。让不同应用能轻松地通过容器名互相访问。</p><div class=single-subsummary><img src=/avatar.jpg alt="Author Avatar"><div><p class=author>ghung</p><p class=single-date><time datetime=2025-07-28T00:00:00+00:00>2025 Jul 28</time>
&nbsp; · &nbsp;1 min read</p></div></div></header><div class=single-tags><span><a href=https://blog.yzyy.de/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/>#服务器</a>
</span><span><a href=https://blog.yzyy.de/tags/%E6%8E%A2%E7%B4%A2/>#探索</a></span></div><aside class=toc><p><strong>Table of contents</strong></p><nav id=TableOfContents><ul><li><a href=#创建共享网络>创建共享网络</a></li><li><a href=#修改不同容器所在的-docker-composeyml>修改不同容器所在的 docker-compose.yml</a></li></ul></nav></aside><div class=single-content><p>由于部署了很多中转代理服务以及各种客户端，常常会遇到多个docker容器间通信的问题。例如，为了解决New-API以及OpenWebUI两个容器间的通信，减少API时延，之前都是采用放在同一个docker-compose中管理，在内部创建一个网络并接入。</p><p>这样也可以实现使用<code>http://newapi:3000/v1</code>的优雅方式访问。</p><p>随着docker-compose文件的越来越长，维护难度越来越高，越来越像一个大杂烩。我又学习了另外一种创建外部网络的方式。</p><hr><p>思路是：我们创建一个独立于任何 docker-compose 文件的共享网络，然后让两个不同的 docker-compose 项目都连接到这个网络上。</p><h2 class=heading id=创建共享网络>创建共享网络
<a class=anchor href=#%e5%88%9b%e5%bb%ba%e5%85%b1%e4%ba%ab%e7%bd%91%e7%bb%9c>#</a></h2><p>运行以下命令来创建一个新的桥接网络。我们就叫它 shared-net。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker network create shared-net
</span></span></code></pre></div><p>这个网络现在独立存在，不受任何 docker-compose 文件的 up 或 down 命令影响。</p><h2 class=heading id=修改不同容器所在的-docker-composeyml>修改不同容器所在的 docker-compose.yml
<a class=anchor href=#%e4%bf%ae%e6%94%b9%e4%b8%8d%e5%90%8c%e5%ae%b9%e5%99%a8%e6%89%80%e5%9c%a8%e7%9a%84-docker-composeyml>#</a></h2><p>编辑容器的 docker-compose.yml 文件，让它连接到我们刚刚创建的 shared-net。</p><p>只需要编辑两个地方：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#888;font-style:italic># 例如在 new-api 项目的 docker-compose.yml 文件中</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>services:
</span></span><span style=display:flex><span>  new-api:
</span></span><span style=display:flex><span>    <span style=color:#888;font-style:italic># ... (它所有现有的配置都保持不变) ...</span>
</span></span><span style=display:flex><span>    networks: <span style=color:#888;font-style:italic># 1.给 new-api 服务添加这个 networks 块</span>
</span></span><span style=display:flex><span>      - some-other-network <span style=color:#888;font-style:italic># 它可能已经连接了其他网络，保留它们</span>
</span></span><span style=display:flex><span>      - shared-net <span style=color:#888;font-style:italic># 额外连接到我们的共享网络</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic># 2. 在文件末尾声明这个网络是外部的</span>
</span></span><span style=display:flex><span>networks:
</span></span><span style=display:flex><span>  some-other-network:
</span></span><span style=display:flex><span>    <span style=color:#888;font-style:italic># ...</span>
</span></span><span style=display:flex><span>  shared-net:
</span></span><span style=display:flex><span>    external: <span style=font-weight:700;text-decoration:underline>true</span>
</span></span></code></pre></div><hr><p>之后，重启容器。</p><p>现在，因为不同容器都在 shared-net 这个网络里，它们可以通过容器名直接通信。要访问 「new-api」 ，地址应该填写：<code>http://new-api:3000</code>。</p></div></article><div class=single-comments><script src=https://giscus.app/client.js data-repo=eaiu/eaiu.github.io data-repo-id=R_kgDOPMv-Yw data-category data-category-id=DIC_kwDOPMv-Y84CtAeO data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=en data-loading=lazy crossorigin=anonymous async></script></div><div class=single-pagination><hr><div class=flexnowrap><div class=single-pagination-prev><div class=single-pagination-container-prev><div class=single-pagination-text>←</div><div class=single-pagination-text><a href=/post/%E6%96%B0%E8%B4%AD%E4%B8%80%E5%8F%B08gb%E7%9A%84vds/>新购一台8GB的VDS与搬家</a></div></div></div><div class=single-pagination-next></div></div><hr></div><div class=back-to-top><a href=#top>back to top</a></div></div></main></div><footer><p>All content licensed under <a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a> unless otherwise stated. Copyright © 2025 ghung<br>Powered by <a href=https://gohugo.io/>Hugo</a> and <a href=https://github.com/tomfran/typo>tomfran/typo</a></p></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script></body><script src=/js/theme-switch.js></script><script defer src=/js/copy-code.js></script></html>