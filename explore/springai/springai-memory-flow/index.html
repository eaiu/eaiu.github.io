<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><link rel=icon type=image/ico href=https://blog.yzyy.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.yzyy.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.yzyy.de/favicon-32x32.png><link rel=icon type=image/png sizes=192x192 href=https://blog.yzyy.de/android-chrome-192x192.png><link rel=apple-touch-icon sizes=180x180 href=https://blog.yzyy.de/apple-touch-icon.png><meta name=description content><title>| G-Hung的博客</title><link rel=canonical href=https://blog.yzyy.de/explore/springai/springai-memory-flow/><meta property="og:url" content="https://blog.yzyy.de/explore/springai/springai-memory-flow/"><meta property="og:site_name" content="G-Hung的博客"><meta property="og:title" content="G-Hung的博客"><meta property="og:description" content='Spring AI 对话记忆管理流程图 # 本文档展示了 Spring AI 对话记忆管理的完整流程，以用户发送消息 "帮我总结一下刚才的内容" (conversationId: "user-9527") 为例。
完整时序图 # sequenceDiagram autonumber participant User as 用户/前端 participant Controller as Controller participant ChatClient as ChatClient participant Advisor as MessageChatMemoryAdvisor participant Memory as TokenWindowChatMemory participant Repo as RedisChatMemoryRepository participant Redis as Redis participant AI as AI模型 rect rgb(240, 248, 255) Note over User,Redis: 第一阶段:读取与筛选 (Before Request) User->>Controller: 发送消息 (conversationId: user-9527) Controller->>ChatClient: chatClient.prompt().user(...).call() ChatClient->>Advisor: 拦截请求 (Before Request) Note over Advisor: 发现 conversationId=user-9527 Advisor->>Memory: get(user-9527, ...) Note over Advisor,Memory: 请求历史记忆 Memory->>Repo: 查询存储的消息 Repo->>Redis: redisTemplate.opsForValue().get(chat:memory:user-9527) Note over Redis: 返回 JSON 字符串 (50条历史对话) Redis-->>Repo: String (JSON) Repo-->>Memory: 反序列化为 List Message (全量50条) Note over Memory: Token策略计算: 1.引入Tokenizer 2.从最后一条往前倒推 3.累加至2000Token限制 4.倒数第8条时满了 Memory-->>Advisor: 返回精简切片 (8条历史+SystemMessage) end rect rgb(255, 250, 240) Note over Advisor,AI: 第二阶段:组装与发送 (Requesting) Note over Advisor: 组装最终Prompt: SystemPrompt + 8条历史 + 当前新问题 Advisor->>AI: 发送完整请求包 end rect rgb(240, 255, 240) Note over AI: 第三阶段:AI响应 (Response) Note over AI: AI理解上下文并思考 AI-->>Advisor: 返回回复内容 end rect rgb(255, 240, 245) Note over Advisor,Redis: 第四阶段:写入与更新 (After Request) Note over Advisor: 捕获本轮对话: 用户提问 + AI回复 Advisor->>Memory: add(user-9527, [UserMsg, AssistantMsg]) Note over Memory: 追加新消息到列表 (50条→52条) Memory->>Repo: update(...) Repo->>Redis: 序列化为JSON并覆盖写入, 刷新TTL Redis-->>Repo: 确认写入 Repo-->>Memory: 更新成功 Memory-->>Advisor: 存储完成 end Advisor-->>ChatClient: 返回AI响应 ChatClient-->>Controller: 返回结果 Controller-->>User: 返回回复内容 数据形态变化表 # 环节 数据形态 数量示例 备注 Redis 中 String (JSON) 50条 全量存档。例如：[{"role":"user","content":"..."}, ...] Repo → Memory List<Message> 50条 全量对象。内存里有 50 个 Message 对象 Memory → Advisor List<Message> 8条 精简切片。经过 Token 算法裁剪，只剩 8 个 Message 对象 发给 AI 的包 Prompt 1+8+1 最终请求。包含 System + 8条历史 + 1条新消息 Redis (更新后) String (JSON) 52条 全量存档+2。变成了 52 条，等待下一次调用 核心组件职责 # graph TB subgraph "存储层" Redis[(Redis 数据库)] Repo[RedisChatMemoryRepository] end subgraph "策略层" Memory[TokenWindowChatMemory] Tokenizer[Token 计算器] end subgraph "增强层" Advisor[MessageChatMemoryAdvisor] end subgraph "应用层" ChatClient[ChatClient] Controller[Controller] end Controller --> ChatClient ChatClient --> Advisor Advisor --> Memory Memory --> Tokenizer Memory --> Repo Repo --> Redis style Redis fill:#ffcccc style Repo fill:#ffe6cc style Memory fill:#fff4cc style Tokenizer fill:#fff4cc style Advisor fill:#e6f3ff style ChatClient fill:#f0f0f0 style Controller fill:#f0f0f0 Token 窗口计算流程 # flowchart TD Start([收到50条历史消息]) --> Init[初始化 Token 计数器 = 0] Init --> Loop{从最后一条往前遍历} Loop -->|取一条消息| Calc[计算该消息的 Token 数] Calc --> Add[累加到计数器] Add --> Check{累加后是否超过2000 Token?} Check -->|否| Loop Check -->|是| Stop[停止遍历] Stop --> Result[返回最近的 8 条消息] Loop -->|遍历完所有消息| Result Result --> End([发送给 Advisor]) style Start fill:#e1f5e1 style End fill:#e1f5e1 style Check fill:#ffe6e6 style Result fill:#e6f3ff 设计优势 # 1. 职责分离 # Redis：只管存 JSON，不懂业务逻辑 Repository：只管序列化/反序列化，不懂 Token Memory：只管 Token 计算，不管 IO Advisor：只管请求增强，不管存储细节 2. 性能优化 # Token 计算在内存中完成，速度极快 Redis 存储全量数据，但只传输必要的切片给 AI 避免每次都重新计算整个对话历史 3. 可扩展性 # 可以轻松替换存储层（Redis → MySQL → MongoDB） 可以调整 Token 窗口大小 可以实现不同的记忆策略（滑动窗口、摘要压缩等） 4. AI 友好 # 无论 Redis 存了多少条消息，发给 AI 的永远不会超过 Token 限制 保证 AI 始终能获得最相关的上下文 避免超长请求导致的错误或额外费用'><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="explore"><link rel=stylesheet href=/assets/combined.min.737dab787e0dfa3088180adf040304574c336cd3805516c938598d23fd96b675.css media=all><script async src="https://www.googletagmanager.com/gtag/js?id=G-88BLW4V0HZ"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-88BLW4V0HZ")}</script></head><body class=auto><div class=content><header><div class=header><h1 class=header-title><a href=https://blog.yzyy.de/>G-Hung的博客</a></h1><div class=header-menu><p class=small><a href=/>/home</a></p><p class=small><a href=/post>/日常</a></p><p class=small><a href=/explore>/探索记录</a></p><p class=small><a href=/tags>/tags</a></p><a href=/index.xml target=_blank title=RSS class=rss-icon><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></div></div></header><main class=main><div class=breadcrumbs><a href=/>Home</a><span class=breadcrumbs-separator>/</span><a href=/explore/>Explores</a><span class=breadcrumbs-separator>/</span>
<a href=/explore/springai/springai-memory-flow/></a></div><div><article><header class=single-intro-container><h1 class=single-title></h1></header><div class=single-content><h1 class=heading id=spring-ai-对话记忆管理流程图>Spring AI 对话记忆管理流程图
<a class=anchor href=#spring-ai-%e5%af%b9%e8%af%9d%e8%ae%b0%e5%bf%86%e7%ae%a1%e7%90%86%e6%b5%81%e7%a8%8b%e5%9b%be>#</a></h1><p>本文档展示了 Spring AI 对话记忆管理的完整流程，以用户发送消息 <code>"帮我总结一下刚才的内容"</code> (conversationId: <code>"user-9527"</code>) 为例。</p><h2 class=heading id=完整时序图>完整时序图
<a class=anchor href=#%e5%ae%8c%e6%95%b4%e6%97%b6%e5%ba%8f%e5%9b%be>#</a></h2><p><figure><div class=img-container><img loading=lazy alt=Image_2025-11-25_16-17-39_vavz5awg.vhe.png src=https://webp.050612.xyz/2025/11/20251125161755002.png></div></figure></p><pre class=mermaid>sequenceDiagram
    autonumber
    participant User as 用户/前端
    participant Controller as Controller
    participant ChatClient as ChatClient
    participant Advisor as MessageChatMemoryAdvisor
    participant Memory as TokenWindowChatMemory
    participant Repo as RedisChatMemoryRepository
    participant Redis as Redis
    participant AI as AI模型

    rect rgb(240, 248, 255)
        Note over User,Redis: 第一阶段:读取与筛选 (Before Request)
        User-&gt;&gt;Controller: 发送消息 (conversationId: user-9527)
        Controller-&gt;&gt;ChatClient: chatClient.prompt().user(...).call()
        ChatClient-&gt;&gt;Advisor: 拦截请求 (Before Request)
        Note over Advisor: 发现 conversationId=user-9527
        
        Advisor-&gt;&gt;Memory: get(user-9527, ...)
        Note over Advisor,Memory: 请求历史记忆
        
        Memory-&gt;&gt;Repo: 查询存储的消息
        Repo-&gt;&gt;Redis: redisTemplate.opsForValue().get(chat:memory:user-9527)
        Note over Redis: 返回 JSON 字符串 (50条历史对话)
        Redis--&gt;&gt;Repo: String (JSON)
        Repo--&gt;&gt;Memory: 反序列化为 List Message (全量50条)
        
        Note over Memory: Token策略计算: 1.引入Tokenizer 2.从最后一条往前倒推 3.累加至2000Token限制 4.倒数第8条时满了
        Memory--&gt;&gt;Advisor: 返回精简切片 (8条历史+SystemMessage)
    end

    rect rgb(255, 250, 240)
        Note over Advisor,AI: 第二阶段:组装与发送 (Requesting)
        Note over Advisor: 组装最终Prompt: SystemPrompt + 8条历史 + 当前新问题
        Advisor-&gt;&gt;AI: 发送完整请求包
    end

    rect rgb(240, 255, 240)
        Note over AI: 第三阶段:AI响应 (Response)
        Note over AI: AI理解上下文并思考
        AI--&gt;&gt;Advisor: 返回回复内容
    end

    rect rgb(255, 240, 245)
        Note over Advisor,Redis: 第四阶段:写入与更新 (After Request)
        Note over Advisor: 捕获本轮对话: 用户提问 + AI回复
        
        Advisor-&gt;&gt;Memory: add(user-9527, [UserMsg, AssistantMsg])
        Note over Memory: 追加新消息到列表 (50条→52条)
        
        Memory-&gt;&gt;Repo: update(...)
        Repo-&gt;&gt;Redis: 序列化为JSON并覆盖写入, 刷新TTL
        Redis--&gt;&gt;Repo: 确认写入
        Repo--&gt;&gt;Memory: 更新成功
        Memory--&gt;&gt;Advisor: 存储完成
    end
    
    Advisor--&gt;&gt;ChatClient: 返回AI响应
    ChatClient--&gt;&gt;Controller: 返回结果
    Controller--&gt;&gt;User: 返回回复内容
</pre><h2 class=heading id=数据形态变化表>数据形态变化表
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e5%bd%a2%e6%80%81%e5%8f%98%e5%8c%96%e8%a1%a8>#</a></h2><div class=table-outer><table><thead><tr><th style=text-align:left>环节</th><th style=text-align:left>数据形态</th><th style=text-align:center>数量示例</th><th style=text-align:left>备注</th></tr></thead><tbody><tr><td style=text-align:left><strong>Redis 中</strong></td><td style=text-align:left><code>String</code> (JSON)</td><td style=text-align:center>50条</td><td style=text-align:left><strong>全量存档</strong>。例如：<code>[{"role":"user","content":"..."}, ...]</code></td></tr><tr><td style=text-align:left><strong>Repo → Memory</strong></td><td style=text-align:left><code>List&lt;Message></code></td><td style=text-align:center>50条</td><td style=text-align:left><strong>全量对象</strong>。内存里有 50 个 Message 对象</td></tr><tr><td style=text-align:left><strong>Memory → Advisor</strong></td><td style=text-align:left><code>List&lt;Message></code></td><td style=text-align:center>8条</td><td style=text-align:left><strong>精简切片</strong>。经过 Token 算法裁剪，只剩 8 个 Message 对象</td></tr><tr><td style=text-align:left><strong>发给 AI 的包</strong></td><td style=text-align:left><code>Prompt</code></td><td style=text-align:center>1+8+1</td><td style=text-align:left><strong>最终请求</strong>。包含 System + 8条历史 + 1条新消息</td></tr><tr><td style=text-align:left><strong>Redis (更新后)</strong></td><td style=text-align:left><code>String</code> (JSON)</td><td style=text-align:center>52条</td><td style=text-align:left><strong>全量存档+2</strong>。变成了 52 条，等待下一次调用</td></tr></tbody></table></div><h2 class=heading id=核心组件职责>核心组件职责
<a class=anchor href=#%e6%a0%b8%e5%bf%83%e7%bb%84%e4%bb%b6%e8%81%8c%e8%b4%a3>#</a></h2><pre class=mermaid>graph TB
    subgraph &#34;存储层&#34;
        Redis[(Redis 数据库)]
        Repo[RedisChatMemoryRepository]
    end
    
    subgraph &#34;策略层&#34;
        Memory[TokenWindowChatMemory]
        Tokenizer[Token 计算器]
    end
    
    subgraph &#34;增强层&#34;
        Advisor[MessageChatMemoryAdvisor]
    end
    
    subgraph &#34;应用层&#34;
        ChatClient[ChatClient]
        Controller[Controller]
    end
    
    Controller --&gt; ChatClient
    ChatClient --&gt; Advisor
    Advisor --&gt; Memory
    Memory --&gt; Tokenizer
    Memory --&gt; Repo
    Repo --&gt; Redis
    
    style Redis fill:#ffcccc
    style Repo fill:#ffe6cc
    style Memory fill:#fff4cc
    style Tokenizer fill:#fff4cc
    style Advisor fill:#e6f3ff
    style ChatClient fill:#f0f0f0
    style Controller fill:#f0f0f0
</pre><h2 class=heading id=token-窗口计算流程>Token 窗口计算流程
<a class=anchor href=#token-%e7%aa%97%e5%8f%a3%e8%ae%a1%e7%ae%97%e6%b5%81%e7%a8%8b>#</a></h2><pre class=mermaid>flowchart TD
    Start([收到50条历史消息]) --&gt; Init[初始化 Token 计数器 = 0]
    Init --&gt; Loop{从最后一条往前遍历}
    Loop --&gt;|取一条消息| Calc[计算该消息的 Token 数]
    Calc --&gt; Add[累加到计数器]
    Add --&gt; Check{累加后是否超过2000 Token?}
    Check --&gt;|否| Loop
    Check --&gt;|是| Stop[停止遍历]
    Stop --&gt; Result[返回最近的 8 条消息]
    Loop --&gt;|遍历完所有消息| Result
    Result --&gt; End([发送给 Advisor])
    
    style Start fill:#e1f5e1
    style End fill:#e1f5e1
    style Check fill:#ffe6e6
    style Result fill:#e6f3ff
</pre><h2 class=heading id=设计优势>设计优势
<a class=anchor href=#%e8%ae%be%e8%ae%a1%e4%bc%98%e5%8a%bf>#</a></h2><h3 class=heading id=1-职责分离>1. <strong>职责分离</strong>
<a class=anchor href=#1-%e8%81%8c%e8%b4%a3%e5%88%86%e7%a6%bb>#</a></h3><ul><li><strong>Redis</strong>：只管存 JSON，不懂业务逻辑</li><li><strong>Repository</strong>：只管序列化/反序列化，不懂 Token</li><li><strong>Memory</strong>：只管 Token 计算，不管 IO</li><li><strong>Advisor</strong>：只管请求增强，不管存储细节</li></ul><h3 class=heading id=2-性能优化>2. <strong>性能优化</strong>
<a class=anchor href=#2-%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96>#</a></h3><ul><li>Token 计算在内存中完成，速度极快</li><li>Redis 存储全量数据，但只传输必要的切片给 AI</li><li>避免每次都重新计算整个对话历史</li></ul><h3 class=heading id=3-可扩展性>3. <strong>可扩展性</strong>
<a class=anchor href=#3-%e5%8f%af%e6%89%a9%e5%b1%95%e6%80%a7>#</a></h3><ul><li>可以轻松替换存储层（Redis → MySQL → MongoDB）</li><li>可以调整 Token 窗口大小</li><li>可以实现不同的记忆策略（滑动窗口、摘要压缩等）</li></ul><h3 class=heading id=4-ai-友好>4. <strong>AI 友好</strong>
<a class=anchor href=#4-ai-%e5%8f%8b%e5%a5%bd>#</a></h3><ul><li>无论 Redis 存了多少条消息，发给 AI 的永远不会超过 Token 限制</li><li>保证 AI 始终能获得最相关的上下文</li><li>避免超长请求导致的错误或额外费用</li></ul></div></article><div class=single-comments><script src=https://giscus.app/client.js data-repo=eaiu/eaiu.github.io data-repo-id=R_kgDOPMv-Yw data-category data-category-id=DIC_kwDOPMv-Y84CtAeO data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=en data-loading=lazy crossorigin=anonymous async></script></div><script defer type=module id=mermaid_script data-light-theme=default data-dark-theme=dark src=/js/mermaid.js>
  </script><div class=single-pagination><hr><div class=flexnowrap><div class=single-pagination-prev></div><div class=single-pagination-next><div class=single-pagination-container-next><div class=single-pagination-text><a href=/explore/obsidian%E4%B8%AA%E4%BA%BA%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/>Obsdian个人配置记录</a></div><div class=single-pagination-text>→</div></div></div></div><hr></div><div class=back-to-top><a href=#top>back to top</a></div></div></main></div><footer><p>All content licensed under <a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a> unless otherwise stated. Copyright © 2025 ghung<br>Powered by <a href=https://gohugo.io/>Hugo</a> and <a href=https://github.com/tomfran/typo>tomfran/typo</a></p></footer></body><script src=/js/theme-switch.js></script><script defer src=/js/copy-code.js></script></html>